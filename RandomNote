================================================================================================
二叉树
================================================================================================

------------------------------------------------------------------------------------------------

非递归模式

先序
1.头节点入栈
2.while栈不为空
  - 出栈打印
  - 有右儿子节点就入栈
  - 有左儿子节点就出栈

后序
1.头节点入栈1
  while栈1不为空
  - 出栈1，入栈2 pop
  - 有右儿子节点就入栈1 push
  - 有左儿子节点就出栈1 push
2.弹出栈2所有元素，每个打印

中序
大顺序，先左再头再右，用左头去分解
1.while栈不为空，head不为空
    if head不为空
       - head入栈
       - head=head.left
    else 
       - 弹出并打印
       - head切换到head的右树

bfs
用队列实现
1.头节点入队列
2.while队列不为空
  - 出队列并打印 poll
  - 有左儿子节点(即左儿子不为null)就入队列 add
  - 有右儿子节点(即右儿子不为null)就入队列 add

统计二叉树中宽度最大的一层，返回宽度（按层打印，求最大宽度）
方法1
bsf遍历中，记录下每一个节点所在的层数
在确定当前层结束的时候进行统计，然后更新max
不要忘记最后一层是没有办法触发的，需要队列while循环之外再单独做一个max

方法2
用指针，一边遍历一边计算下一层的最右也就是停止节点，如果遍历到了这个节点就开始结算
核心变量
- 当前层node数量
- 当前node指针
- 当前层最右边node指针
  下一层最右边node指针

二叉树的序列化和反序列化
前序，中序，后序
和打印类似，都是通过递归序去做，然后把null节点补全，并且适当地地方构建node

按层遍历

------------------------------------------------------------------------------------------------

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）


------------------------------------------------------------------------------------------------

求二叉树的各种最值，就想应该采用什么样的遍历顺序，确定了遍历循序，其实就和数组求最值一样容易了

------------------------------------------------------------------------------------------------

再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）


------------------------------------------------------------------------------------------------

一些同学也会疑惑，什么时候递归函数前面加if，什么时候不加if，这个问题我在最后也给出了解释。

其实就是不同代码风格的实现，一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整


------------------------------------------------------------------------------------------------

二叉树的删除，搜索树和普通树
https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E9%80%92%E5%BD%92

------------------------------------------------------------------------------------------------

二叉树总结
https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC

------------------------------------------------------------------------------------------------


================================================================================================
数组
================================================================================================

------------------------------------------------------------------------------------------------

数组总结
https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html

------------------------------------------------------------------------------------------------


3 5 2 6 6 7
k=4
队列 <- [7]

------------------------------------------------------------------------------------------------



================================================================================================
回溯
================================================================================================


------------------------------------------------------------------------------------------------

void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}


dp[2]=10
30
15


dp[4]=dp[4]+dp[3]
dp[3]=dp[3]+dp[2]
dp[2]=dp[2]+dp[1]
dp[1]=dp[1]+dp[0]


 2 5 1 2 5
   |  
10 5 2 1 5 2



================================================================================================


滑动窗口
左闭右开
https://labuladong.gitee.io/algo/2/19/26/

/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}

================================================================================================

单调队列
https://labuladong.gitee.io/algo/2/22/63/

1.既要满足“FIFO”的顺序，又要能够维护队列中所有元素的最值 -> 单调队列

================================================================================================

queue和deque常用方法
https://blog.csdn.net/licux/article/details/121021393

offer
peek
poll

offerFirst/offerLast
peekFirst/peekLast
pollFirst/pollLast

大小堆的Comparator理解
https://blog.csdn.net/weixin_45813747/article/details/114850657
简而言之，返回1的时候进行位置交换

================================================================================================

二分查找
https://labuladong.github.io/algo/1/11/

int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 此时 left - 1 索引越界
    if (left == 0) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left - 1] == target ? (left - 1) : -1;
}


================================================================================================

图
dfs -> 关注更多是节点
回溯 -> 关注更多数边


================================================================================================

[3, 3, 3, 3, 10]


1 2 3
4 5 6
7 8 9


2 3 0 4 7 4 1 6 


0、1、2、3、4、5、6、7、8、9

第1轮 余数=7，删除6
第2轮 余数=8，删除7
第3轮 余数=8，删除7

n=10 m=17
m%n -> table[m%n-1] 删除
m%(n-1) -> table[m%(n-1)-1] 删除

3、



[7,5,6,4]

[7,5]
[6,4]
[5,4]
[7,6]
[7,4]


[-4,-1,-1,0,1,2]

abba

0123


left = i-currentRoundMax/2+1/2;

left = i-currentRoundMax/2+1;


// 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }


            int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }

2 2 3
2 3 2
3 2 2
7 


[0,1,0,3,12]

[1,0,0,3,12]

[1,3,0,0,12]

[1,3,0,12,0]

[1,0,0,3,12]

[1,3,0,0,12]

[1,3,12,0,0]


=========================================================================================================

刷题
https://zxi.mytechroad.com/blog/leetcode-problem-categories/
https://github.com/wisdompeak/LeetCode

古城算法
https://space.bilibili.com/21630984


=========================================================================================================

二分

lc33 搜索旋转排序数组 好的写法，先找切分点
里面包含题单
https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/shua-chuan-lc-yan-ge-ologn100yi-qi-kan-q-xifo/

二分模板总结
https://segmentfault.com/a/1190000016825704

二分题目单，宫水三叶
https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E4%BA%8C%E5%88%86




        // 还是找左边界，即旋转完成后最小值开始的那个index
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[nums.length-1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return nums[left];




2147483647



=========================================================================================================

分治

LC 327

LC 493

LC 654 最大二叉树

可知该问题本质是「区间求最值」问题（RMQ），可以扩展使用单调栈，线段树

LC 912 排序

扩展 算法学习笔记(2) : 树状数组
https://zhuanlan.zhihu.com/p/93795692


LC 04

三叶的解法，比较简洁，分治+递归
https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/shua-chuan-lc-po-su-jie-fa-fen-zhi-jie-f-wtu2/


LC 169 分治或者vote算法

模板写法
    public int majorityElement(int[] nums) {
        return devide(nums, 0, nums.length - 1);
    }

    private int devide(int[] nums, int left, int right) {
        // last element
        if (left == right) {
            return nums[left];
        }
        // 开始切分, 如果2边结果一样，可以返回任何一个结果
        int mid = left + (right - left) / 2;
        int leftRes = devide(nums, left, mid);
        int rightRes = devide(nums, mid+1, right);
        if (leftRes == rightRes) {
            return leftRes;
        }
        // 如果结果不一样，则需要进行conquer，即计数统计出出现最大那个
        int leftCount = conquer(nums, left, mid, leftRes);
        int rightCount = conquer(nums, mid+1, right, rightRes);
        if (leftCount > rightCount) {
            return leftRes;
        } else {
            return rightRes;
        }
    }

    private int conquer(int[] nums, int left, int right, int res) {
        int count = 0;
        for (int i=left; i<=right; i++) {
            if (nums[i] == res) {
                count++;
            }
        }
        return count;
    }


LC 229 众数的姊妹题

推广到n/k的场景
https://leetcode.cn/problems/majority-element-ii/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ws0rj/


LC 23 mergeSortedLists

1. 分治+优先队列 2种写法
2. Comparator写法比较难记录，ele1 ele2 如果ele1要排在ele2前面，需要-1，e.g. 4->5 需要return ele1.val - ele2.val


LC 50 快速幂

done 后续可以尝试递归+迭代2种写法


LC 215 quick select 第k大的数

3种写法进行quick select
https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/1282560/cpython3java-1da-gen-dui-diao-ku-2shou-l-xveq/


pivot := A[lo]
    i := lo - 1
    j := hi + 1
    loop forever
        do
            i := i + 1
        while A[i] < pivot

        do
            j := j - 1
        while A[j] > pivot

        if i >= j then
            return j

        swap A[i] with A[j]

partition的算法
https://www.freecodecamp.org/news/quickselect-algorithm-explained-with-examples/        



LC 315 计算右侧小于当前元素的个数

1.对于要统计各个位置上面的数和后面的数的大小关系的，这种需要使用indexes去记录，因为只有知道相对位置才方便记录处理

结合剑指offer 51题逆序对一起看

merge sort的算法
https://www.geeksforgeeks.org/merge-sort/

inversion pair count
https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/


MergeSort(arr[], l,  r)

If r > l

- Find the middle point to divide the array into two halves: 
  middle m = l + (r – l)/2
- Call mergeSort for first half:   
  Call mergeSort(arr, l, m)
- Call mergeSort for second half:
  Call mergeSort(arr, m + 1, r)
- Merge the two halves sorted in steps 2 and 3:
  Call merge(arr, l, m, r)



Cloest pair of points

https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/



LC 327 区间和的个数


[-2 5 1]

step 1

sortLeft left=0 right=1
sortRight left=2 right=2
mergeTogether left=0 mid=1 right=2

step 2

sortLeft left=0 right=0
sortRight left=1 right=1
mergeTogether left=0 mid=0 right=1

step 3

sortLeft left=2 right=2
sortRight left=3 right=2
mergeTogether left=2 mid=2 right=2




LC 912 排序

复习排序算法
https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/

LC 493

LC 654

=========================================================================================================

单调栈

5 6 4 7 5 2

以下模拟左边求第一个比当前小的数

-> 

5 6 
6 -> 4
5 -> 4
4 7
7 -> 5
4 5
5 -> 2
4 -> 2
2

以下模拟右边求第一个比当前小的数

2 5 7 
7 -> 4
5 -> 4
2 4 6
6 -> 5
2 4 5

1. 存游标会方便处理很多

LC 316 去除重复字母

有点坑，写的一塌糊涂，完全没有正确的思路

weiwei哥的题单
https://leetcode.cn/problems/remove-duplicate-letters/solutions/55044/zhan-by-liweiwei1419/

LC 42 接雨水
 
1.可以加一个哨兵值比如-1进去，也可以通过while循环里面判断栈为空则break的方式
2.实际栈中不是完全单调，需要考虑一样高度的柱子
3.还有面积叠加法(类似阳光照射)和动态规划(进一步可以优化成双指针)，复习的时候可以再做一下

LC 84 最大长方形面积 在histogram中

1.弹出的时候要特别小心，需要用当前弹出元素前面的index+1，因为我们能够弹出的元素都是之前递增的元素，所以一定是要把前面位置已经弹出的index记录的
2.左右2边分别用2个stack统计的做法，更容易理解，但和点1一样最终还是靠统计index位置，即使用peek

LC 221 最大正方形

实际不适合用单调栈，用dp比较合适

LC 255 付费的

LC 456 132模式

1.如果从前往后不太好想，就要试下从后往前去想找单调性
2.每次找到不满足当前预设的单调性的数字的时候，出栈，这个时候出栈的元素和栈顶的元素就可能构成的是另一个方向单调性的一对
  进一步，可以去记录这个出栈元素的最值，去和遍历方向的元素的值去进行比较，找答案

LC 769 最多能完成排序的块

不是这么显著的单调栈场景
1.单调可能是在不同的区间的最值基础上单调，e.g. 区间a和区间b的最大值/区间保持单调
2.基于点1的场景就要考虑在移出栈的元素后记录区间内的一个“最值”，而不是存放符合区间条件的所有值

LC 769 最多能完成排序的块2

和上一题基本一样的单调栈解法

==============================================================================================================================

单调队列

通用步骤
1.去尾，即腾出空间让对象入列
2.保持队列单调性，涉及到重新调整顺序的操作; 调整到合适位置后，将新元素入队列
3.返回最值，一般是头部

LC 239 滑动窗口最大值

模板题，没啥说的

LC 862 和至少为K的最短子数组

看清题目，是至少大于k
1.理解清楚左边指的是队列头，右边指的是队列尾，因为我们一般都是从左边开始进队列
2.一旦有说求子数组的和，乘积之类的，就要想是不是需要做前缀和/乘积的处理
3.有正有负值的场景，大概率是不能简单的去滑动窗口的，因为窗口里面的和不具备单调性


几个场景
1.如果s[i]<=s[j],i>j, 则s[j]一定会被s[i]“短路”，因为假设后面存在和大于k的子数组(s[x]-s[j]>=k)，则s[x]-s[i]>=k先行已经满足
  暗含的逻辑即遇到上面的场景要弹出s[j]，在队列中保持单调递增，这里从队尾开始进行判断弹出满足条件的元素
  如果不弹出，就可能会出现被前面一个高点的值给短路求不出解的情况，e.g. 3 6 10 8 9 17 k=8 最终是结尾的17-9=8满足要求
2.从队列头开始，如果当前s[i]-s[peekFirst()]>=k，则记录值，这里也有一个可以优化的点
  即假如s[i]-s[peekFirst()]>=k，则i再往后的元素都不会满足要求，因为后续的x>i，满足要求的子数组大小都会比当前的子数组大小要来的大


LC 1425 带限制的子序列和

1.子数组最大值，且满足相邻2个数坐标i和j之间的举例小于等于k，先看下什么方向，比如dp能不能搞

以元素i结尾的子序列中元素和的值最大值(子序列为空，所以必有元素) 即nums[i]一定是被pick了
dp[i] = max(nums[i], dp[i-j] + nums[i]) 枚举所有j的值 j = [1,k]

几种case
1.只选nums[i]，即i之前的序列为空
2.枚举宽度为k的窗口中所有的可能性, dp[i-k]到dp[i-1] while i-k>=0 小于0则取0

最终结果 max(dp[0], dp[1], ..., dp[nums.length - 1])

O(nk) 复杂度 基本会超时，看下怎么优化


[-10,-2,100,-5,-6,7] k=2


dp[0] = nums[0] = -10
dp[1] = max(nums[1], dp[0]+nums[1]) = -2
dp[2] = max(nums[2], dp[1]+nums[2], dp[0]+nums[2]) = max(100, 98, 90) = 100
dp[3] = max(nums[3], dp[2]+nums[3], dp[1]+nums[3]) = max(-5, 95, -7) = 95
dp[4] = max(nums[4], dp[3]+nums[4], dp[2]+nums[4]) = max(-3, 89, 94) = 94
dp[5] = max(nums[5], dp[4]+nums[5], dp[3]+nums[5]) = max(7, 102, 101) = 102


LC 1438 绝对差不超过限制的最长连续子数组

1.不超过限制提示我们会出现当前值i和前面一个片段的上下限都要判断，即比较区间最大值和最小值，最大最小值就要想下是不是保持2个栈去maintain窗口内的2个最值了
2.有窗口特征的，要想下怎么实现left和right的2个指针，并且在合适的时刻更新结果
3.窗口的缩小技巧性很强，缩小的条件是窗口中的最大和最小值相差的绝对值小于等于limit，每次循环累积递增left值，直到min或者max的队列最顶的元素被弹出
  while (Math.abs(nums[maxQueue.peekFirst()] - nums[minQueue.peekFirst()]) > limit) {
                // 进入这里一定是窗口需要调整了, left指向下一个可能valid的位置，这里非常绕，移动了left以后并不一定就到达了需要调整的窗口位置，即只有在下面left大于了max或者min的头节点位置才可能终止当前的循环，完成窗口的缩小
                left++;
                if (maxQueue.peekFirst() < left) {
                    maxQueue.pollFirst();
                }
                if (minQueue.peekFirst() < left) {
                    minQueue.pollFirst();
                }
                System.out.println("left in while -> " + left);
            }


LC 1696 跳跃游戏五

完全是1425的套娃题，解法完全一样，相对更简单一些

1.也可以写那种构建好窗口，然后求dp[i+1]，这种情况下就要从i=0到i=len-2结束

==============================================================================================================================

滑动窗口
 
通用模板
本质还是双指针，左指针left和右指针iterator i
1.进
  当前遍历的元素进入窗口，对应右指针i的移动
2.出
  判断是否符合条件缩小窗口，对应左指针left满足条件后向右的移动
  e.g. 
  while (condition satisfied) {
      update conditon
      left++;
  }
3.算
  一般是在2.的出完成，窗口有效后，更新，常用 i - left + 1 表达窗口的宽度


LC 3 无重复字符的最长子串

模板题，没有太多好说的

LC 159 最多有2个不同字符的最长子串

付费题

class Solution {
    public int lengthOfLongestSubstringWithAtMost2DistinctLetters(String s) {
        if (s == null || s.length == 0) {
            return 0;
        }

        // 滑动窗口
        int left = 0;
        int res = 0;
        Map<Character, Integer> charMemo = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            // current char
            char curChar = s.charAt(i);
            charMemo.put(curChar, charMemo.getOrDefault(curChar, 0) + 1);

            while (charMemo.size() > 2) {
                char leftChar = s.charAt(left);
                charMemo.put(leftChar, charMemo.get(leftChar) - 1);
                if (charMemo.get(leftChar) == 0) {
                    charMemo.remove(leftChar);
                }
                left++;
            }
            res = Math.max(res, i - left + 1);
        }

        return res;
    }
}

LC 340 最多k个不同字符的最长子串

付费题 完全就是LC159的套娃

LC 76 最小覆盖子串

1.题目看清楚，最大最小，返回类型是子串
2.Integer之类的对象类型的一定要注意是用equals去比较，不是==
3.以下做法还能优化，只需要一个map就能记录 
  通过map记录每个letter在字符串t中出现的次数
  通过一个validCount记录多少个字符已经符合要求，一旦符合要求即可以缩小窗口，缩小窗口后判断left指向的字符从tmpMap里面更新，如果减到0则validCount--
  
LC 567 字符串的排列

1.滑动窗口应用，用固定单词窗口移动的方式进行计算会更好
  for (i = wordLen; i < s.length(); i++) {
      count[s.charAt(i) - 'a']++;
      count[s.charAt(i - wordLen) - 'a']--;
      if(checkValid) return true;
  }
