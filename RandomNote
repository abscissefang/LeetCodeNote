================================================================================================
二叉树
================================================================================================

------------------------------------------------------------------------------------------------

非递归模式

先序
1.头节点入栈
2.while栈不为空
  - 出栈打印
  - 有右儿子节点就入栈
  - 有左儿子节点就出栈

后序
1.头节点入栈1
  while栈1不为空
  - 出栈1，入栈2 pop
  - 有右儿子节点就入栈1 push
  - 有左儿子节点就出栈1 push
2.弹出栈2所有元素，每个打印

中序
大顺序，先左再头再右，用左头去分解
1.while栈不为空，head不为空
    if head不为空
       - head入栈
       - head=head.left
    else 
       - 弹出并打印
       - head切换到head的右树

bfs
用队列实现
1.头节点入队列
2.while队列不为空
  - 出队列并打印 poll
  - 有左儿子节点(即左儿子不为null)就入队列 add
  - 有右儿子节点(即右儿子不为null)就入队列 add

统计二叉树中宽度最大的一层，返回宽度（按层打印，求最大宽度）
方法1
bsf遍历中，记录下每一个节点所在的层数
在确定当前层结束的时候进行统计，然后更新max
不要忘记最后一层是没有办法触发的，需要队列while循环之外再单独做一个max

方法2
用指针，一边遍历一边计算下一层的最右也就是停止节点，如果遍历到了这个节点就开始结算
核心变量
- 当前层node数量
- 当前node指针
- 当前层最右边node指针
  下一层最右边node指针

二叉树的序列化和反序列化
前序，中序，后序
和打印类似，都是通过递归序去做，然后把null节点补全，并且适当地地方构建node

按层遍历

------------------------------------------------------------------------------------------------

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）


------------------------------------------------------------------------------------------------

求二叉树的各种最值，就想应该采用什么样的遍历顺序，确定了遍历循序，其实就和数组求最值一样容易了

------------------------------------------------------------------------------------------------

再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）


------------------------------------------------------------------------------------------------

一些同学也会疑惑，什么时候递归函数前面加if，什么时候不加if，这个问题我在最后也给出了解释。

其实就是不同代码风格的实现，一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整


------------------------------------------------------------------------------------------------

二叉树的删除，搜索树和普通树
https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E9%80%92%E5%BD%92

------------------------------------------------------------------------------------------------

二叉树总结
https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC

------------------------------------------------------------------------------------------------


================================================================================================
数组
================================================================================================

------------------------------------------------------------------------------------------------

数组总结
https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html

------------------------------------------------------------------------------------------------


3 5 2 6 6 7
k=4
队列 <- [7]

------------------------------------------------------------------------------------------------



================================================================================================
回溯
================================================================================================


------------------------------------------------------------------------------------------------

void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}


dp[2]=10
30
15


dp[4]=dp[4]+dp[3]
dp[3]=dp[3]+dp[2]
dp[2]=dp[2]+dp[1]
dp[1]=dp[1]+dp[0]


 2 5 1 2 5
   |  
10 5 2 1 5 2



================================================================================================


滑动窗口
左闭右开
https://labuladong.gitee.io/algo/2/19/26/

/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}

================================================================================================

单调队列
https://labuladong.gitee.io/algo/2/22/63/

1.既要满足“FIFO”的顺序，又要能够维护队列中所有元素的最值 -> 单调队列

================================================================================================

queue和deque常用方法
https://blog.csdn.net/licux/article/details/121021393

offer
peek
poll

offerFirst/offerLast
peekFirst/peekLast
pollFirst/pollLast

大小堆的Comparator理解
https://blog.csdn.net/weixin_45813747/article/details/114850657
简而言之，返回1的时候进行位置交换

================================================================================================

二分查找
https://labuladong.github.io/algo/1/11/

int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 此时 left - 1 索引越界
    if (left == 0) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left - 1] == target ? (left - 1) : -1;
}


================================================================================================

图
dfs -> 关注更多是节点
回溯 -> 关注更多数边


================================================================================================

[3, 3, 3, 3, 10]


1 2 3
4 5 6
7 8 9


2 3 0 4 7 4 1 6 


0、1、2、3、4、5、6、7、8、9

第1轮 余数=7，删除6
第2轮 余数=8，删除7
第3轮 余数=8，删除7

n=10 m=17
m%n -> table[m%n-1] 删除
m%(n-1) -> table[m%(n-1)-1] 删除

3、



[7,5,6,4]

[7,5]
[6,4]
[5,4]
[7,6]
[7,4]


[-4,-1,-1,0,1,2]

abba

0123


left = i-currentRoundMax/2+1/2;

left = i-currentRoundMax/2+1;


// 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }


            int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }

2 2 3
2 3 2
3 2 2
7 


[0,1,0,3,12]

[1,0,0,3,12]

[1,3,0,0,12]

[1,3,0,12,0]

[1,0,0,3,12]

[1,3,0,0,12]

[1,3,12,0,0]


=========================================================================================================

刷题
https://zxi.mytechroad.com/blog/leetcode-problem-categories/
https://github.com/wisdompeak/LeetCode

古城算法
https://space.bilibili.com/21630984


=========================================================================================================

二分

lc33 搜索旋转排序数组 好的写法，先找切分点
里面包含题单
https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/shua-chuan-lc-yan-ge-ologn100yi-qi-kan-q-xifo/

二分模板总结
https://segmentfault.com/a/1190000016825704

二分题目单，宫水三叶
https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E4%BA%8C%E5%88%86




        // 还是找左边界，即旋转完成后最小值开始的那个index
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[nums.length-1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return nums[left];




2147483647



=========================================================================================================

分治

LC 327

LC 493

LC 654 最大二叉树

可知该问题本质是「区间求最值」问题（RMQ），可以扩展使用单调栈，线段树

LC 912 排序

扩展 算法学习笔记(2) : 树状数组
https://zhuanlan.zhihu.com/p/93795692


LC 04

三叶的解法，比较简洁，分治+递归
https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/shua-chuan-lc-po-su-jie-fa-fen-zhi-jie-f-wtu2/


LC 169 分治或者vote算法

模板写法
    public int majorityElement(int[] nums) {
        return devide(nums, 0, nums.length - 1);
    }

    private int devide(int[] nums, int left, int right) {
        // last element
        if (left == right) {
            return nums[left];
        }
        // 开始切分, 如果2边结果一样，可以返回任何一个结果
        int mid = left + (right - left) / 2;
        int leftRes = devide(nums, left, mid);
        int rightRes = devide(nums, mid+1, right);
        if (leftRes == rightRes) {
            return leftRes;
        }
        // 如果结果不一样，则需要进行conquer，即计数统计出出现最大那个
        int leftCount = conquer(nums, left, mid, leftRes);
        int rightCount = conquer(nums, mid+1, right, rightRes);
        if (leftCount > rightCount) {
            return leftRes;
        } else {
            return rightRes;
        }
    }

    private int conquer(int[] nums, int left, int right, int res) {
        int count = 0;
        for (int i=left; i<=right; i++) {
            if (nums[i] == res) {
                count++;
            }
        }
        return count;
    }


LC 229 众数的姊妹题

推广到n/k的场景
https://leetcode.cn/problems/majority-element-ii/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ws0rj/


LC 23 mergeSortedLists

1. 分治+优先队列 2种写法
2. Comparator写法比较难记录，ele1 ele2 如果ele1要排在ele2前面，需要-1，e.g. 4->5 需要return ele1.val - ele2.val


LC 50 快速幂

done 后续可以尝试递归+迭代2种写法


LC 215 quick select 第k大的数

3种写法进行quick select
https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/1282560/cpython3java-1da-gen-dui-diao-ku-2shou-l-xveq/


pivot := A[lo]
    i := lo - 1
    j := hi + 1
    loop forever
        do
            i := i + 1
        while A[i] < pivot

        do
            j := j - 1
        while A[j] > pivot

        if i >= j then
            return j

        swap A[i] with A[j]

partition的算法
https://www.freecodecamp.org/news/quickselect-algorithm-explained-with-examples/        



LC 315 计算右侧小于当前元素的个数

1.对于要统计各个位置上面的数和后面的数的大小关系的，这种需要使用indexes去记录，因为只有知道相对位置才方便记录处理

结合剑指offer 51题逆序对一起看

merge sort的算法
https://www.geeksforgeeks.org/merge-sort/

inversion pair count
https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/


MergeSort(arr[], l,  r)

If r > l

- Find the middle point to divide the array into two halves: 
  middle m = l + (r – l)/2
- Call mergeSort for first half:   
  Call mergeSort(arr, l, m)
- Call mergeSort for second half:
  Call mergeSort(arr, m + 1, r)
- Merge the two halves sorted in steps 2 and 3:
  Call merge(arr, l, m, r)



Cloest pair of points

https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/



LC 327 区间和的个数


[-2 5 1]

step 1

sortLeft left=0 right=1
sortRight left=2 right=2
mergeTogether left=0 mid=1 right=2

step 2

sortLeft left=0 right=0
sortRight left=1 right=1
mergeTogether left=0 mid=0 right=1

step 3

sortLeft left=2 right=2
sortRight left=3 right=2
mergeTogether left=2 mid=2 right=2




LC 912 排序

复习排序算法
https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/

LC 493

LC 654

=========================================================================================================

单调栈

5 6 4 7 5 2

以下模拟左边求第一个比当前小的数

-> 

5 6 
6 -> 4
5 -> 4
4 7
7 -> 5
4 5
5 -> 2
4 -> 2
2

以下模拟右边求第一个比当前小的数

2 5 7 
7 -> 4
5 -> 4
2 4 6
6 -> 5
2 4 5

1. 存游标会方便处理很多

LC 316 去除重复字母

有点坑，写的一塌糊涂，完全没有正确的思路

weiwei哥的题单
https://leetcode.cn/problems/remove-duplicate-letters/solutions/55044/zhan-by-liweiwei1419/

LC 402

LC 42 接雨水
 
1.可以加一个哨兵值比如-1进去，也可以通过while循环里面判断栈为空则break的方式
2.实际栈中不是完全单调，需要考虑一样高度的柱子
3.还有面积叠加法(类似阳光照射)和动态规划(进一步可以优化成双指针)，复习的时候可以再做一下

LC 84 最大长方形面积

1.弹出的时候要特别小心，需要用当前弹出元素前面的index+1，因为我们能够弹出的元素都是之前递增的元素，所以一定是要把前面位置已经弹出的index记录的
2.左右2边分别用2个stack统计的做法，更容易理解，但和点1一样最终还是靠统计index位置，即使用peek

LC 85 最大矩形

1.二维矩阵进行记录，特别小心当前格子为0会导致整个“柱子”都变0
2.下一次做可以看下一边迭代一边更新柱子

LC 221 最大正方形

1.实际不适合用单调栈，用dp比较合适

==============================================================================================================================

