================================================================================================
二叉树
================================================================================================

------------------------------------------------------------------------------------------------

非递归模式

先序
1.头节点入栈
2.while栈不为空
  - 出栈打印
  - 有右儿子节点就入栈
  - 有左儿子节点就出栈

后序
1.头节点入栈1
  while栈1不为空
  - 出栈1，入栈2 pop
  - 有右儿子节点就入栈1 push
  - 有左儿子节点就出栈1 push
2.弹出栈2所有元素，每个打印

中序
大顺序，先左再头再右，用左头去分解
1.while栈不为空，head不为空
    if head不为空
       - head入栈
       - head=head.left
    else 
       - 弹出并打印
       - head切换到head的右树

bfs
用队列实现
1.头节点入队列
2.while队列不为空
  - 出队列并打印 poll
  - 有左儿子节点(即左儿子不为null)就入队列 add
  - 有右儿子节点(即右儿子不为null)就入队列 add

统计二叉树中宽度最大的一层，返回宽度（按层打印，求最大宽度）
方法1
bsf遍历中，记录下每一个节点所在的层数
在确定当前层结束的时候进行统计，然后更新max
不要忘记最后一层是没有办法触发的，需要队列while循环之外再单独做一个max

方法2
用指针，一边遍历一边计算下一层的最右也就是停止节点，如果遍历到了这个节点就开始结算
核心变量
- 当前层node数量
- 当前node指针
- 当前层最右边node指针
  下一层最右边node指针

二叉树的序列化和反序列化
前序，中序，后序
和打印类似，都是通过递归序去做，然后把null节点补全，并且适当地地方构建node

按层遍历

------------------------------------------------------------------------------------------------

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）


------------------------------------------------------------------------------------------------

求二叉树的各种最值，就想应该采用什么样的遍历顺序，确定了遍历循序，其实就和数组求最值一样容易了

------------------------------------------------------------------------------------------------

再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）


------------------------------------------------------------------------------------------------

一些同学也会疑惑，什么时候递归函数前面加if，什么时候不加if，这个问题我在最后也给出了解释。

其实就是不同代码风格的实现，一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整


------------------------------------------------------------------------------------------------

二叉树的删除，搜索树和普通树
https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E9%80%92%E5%BD%92

------------------------------------------------------------------------------------------------

二叉树总结
https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC

------------------------------------------------------------------------------------------------


================================================================================================
数组
================================================================================================

------------------------------------------------------------------------------------------------

数组总结
https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html

------------------------------------------------------------------------------------------------


3 5 2 6 6 7
k=4
队列 <- [7]

------------------------------------------------------------------------------------------------



================================================================================================
回溯
================================================================================================


------------------------------------------------------------------------------------------------

void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}


dp[2]=10
30
15


dp[4]=dp[4]+dp[3]
dp[3]=dp[3]+dp[2]
dp[2]=dp[2]+dp[1]
dp[1]=dp[1]+dp[0]


 2 5 1 2 5
   |  
10 5 2 1 5 2



================================================================================================


滑动窗口
左闭右开
https://labuladong.gitee.io/algo/2/19/26/

/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}

================================================================================================

单调队列
https://labuladong.gitee.io/algo/2/22/63/

1.既要满足“FIFO”的顺序，又要能够维护队列中所有元素的最值 -> 单调队列

================================================================================================

queue和deque常用方法
https://blog.csdn.net/licux/article/details/121021393

offer
peek
poll

offerFirst/offerLast
peekFirst/peekLast
pollFirst/pollLast

大小堆的Comparator理解
https://blog.csdn.net/weixin_45813747/article/details/114850657
简而言之，返回1的时候进行位置交换

================================================================================================

二分查找
https://labuladong.github.io/algo/1/11/

int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 此时 left - 1 索引越界
    if (left == 0) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left - 1] == target ? (left - 1) : -1;
}


================================================================================================

图
dfs -> 关注更多是节点
回溯 -> 关注更多数边


================================================================================================

[3, 3, 3, 3, 10]


1 2 3
4 5 6
7 8 9


2 3 0 4 7 4 1 6 


0、1、2、3、4、5、6、7、8、9

第1轮 余数=7，删除6
第2轮 余数=8，删除7
第3轮 余数=8，删除7

n=10 m=17
m%n -> table[m%n-1] 删除
m%(n-1) -> table[m%(n-1)-1] 删除

3、



[7,5,6,4]

[7,5]
[6,4]
[5,4]
[7,6]
[7,4]


[-4,-1,-1,0,1,2]

abba

0123


left = i-currentRoundMax/2+1/2;

left = i-currentRoundMax/2+1;


// 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }


            int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }

2 2 3
2 3 2
3 2 2
7 


[0,1,0,3,12]

[1,0,0,3,12]

[1,3,0,0,12]

[1,3,0,12,0]

[1,0,0,3,12]

[1,3,0,0,12]

[1,3,12,0,0]


=========================================================================================================

刷题
https://zxi.mytechroad.com/blog/leetcode-problem-categories/
https://github.com/wisdompeak/LeetCode

古城算法
https://space.bilibili.com/21630984


=========================================================================================================

二分

lc33 搜索旋转排序数组 好的写法，先找切分点
里面包含题单
https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/shua-chuan-lc-yan-ge-ologn100yi-qi-kan-q-xifo/

二分模板总结
https://segmentfault.com/a/1190000016825704

二分题目单，宫水三叶
https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E4%BA%8C%E5%88%86




        // 还是找左边界，即旋转完成后最小值开始的那个index
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[nums.length-1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return nums[left];




2147483647



=========================================================================================================

分治

LC 327

LC 493

LC 654 最大二叉树

可知该问题本质是「区间求最值」问题（RMQ），可以扩展使用单调栈，线段树

LC 912 排序

扩展 算法学习笔记(2) : 树状数组
https://zhuanlan.zhihu.com/p/93795692


LC 04

三叶的解法，比较简洁，分治+递归
https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/shua-chuan-lc-po-su-jie-fa-fen-zhi-jie-f-wtu2/


LC 169 分治或者vote算法

模板写法
    public int majorityElement(int[] nums) {
        return devide(nums, 0, nums.length - 1);
    }

    private int devide(int[] nums, int left, int right) {
        // last element
        if (left == right) {
            return nums[left];
        }
        // 开始切分, 如果2边结果一样，可以返回任何一个结果
        int mid = left + (right - left) / 2;
        int leftRes = devide(nums, left, mid);
        int rightRes = devide(nums, mid+1, right);
        if (leftRes == rightRes) {
            return leftRes;
        }
        // 如果结果不一样，则需要进行conquer，即计数统计出出现最大那个
        int leftCount = conquer(nums, left, mid, leftRes);
        int rightCount = conquer(nums, mid+1, right, rightRes);
        if (leftCount > rightCount) {
            return leftRes;
        } else {
            return rightRes;
        }
    }

    private int conquer(int[] nums, int left, int right, int res) {
        int count = 0;
        for (int i=left; i<=right; i++) {
            if (nums[i] == res) {
                count++;
            }
        }
        return count;
    }


LC 229 众数的姊妹题

推广到n/k的场景
https://leetcode.cn/problems/majority-element-ii/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ws0rj/


LC 23 mergeSortedLists

1. 分治+优先队列 2种写法
2. Comparator写法比较难记录，ele1 ele2 如果ele1要排在ele2前面，需要-1，e.g. 4->5 需要return ele1.val - ele2.val


LC 50 快速幂

done 后续可以尝试递归+迭代2种写法


LC 215 quick select 第k大的数

3种写法进行quick select
https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/1282560/cpython3java-1da-gen-dui-diao-ku-2shou-l-xveq/


pivot := A[lo]
    i := lo - 1
    j := hi + 1
    loop forever
        do
            i := i + 1
        while A[i] < pivot

        do
            j := j - 1
        while A[j] > pivot

        if i >= j then
            return j

        swap A[i] with A[j]

partition的算法
https://www.freecodecamp.org/news/quickselect-algorithm-explained-with-examples/        



LC 315 计算右侧小于当前元素的个数

1.对于要统计各个位置上面的数和后面的数的大小关系的，这种需要使用indexes去记录，因为只有知道相对位置才方便记录处理

结合剑指offer 51题逆序对一起看

merge sort的算法
https://www.geeksforgeeks.org/merge-sort/

inversion pair count
https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/


MergeSort(arr[], l,  r)

If r > l

- Find the middle point to divide the array into two halves: 
  middle m = l + (r – l)/2
- Call mergeSort for first half:   
  Call mergeSort(arr, l, m)
- Call mergeSort for second half:
  Call mergeSort(arr, m + 1, r)
- Merge the two halves sorted in steps 2 and 3:
  Call merge(arr, l, m, r)



Cloest pair of points

https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/



LC 327 区间和的个数


[-2 5 1]

step 1

sortLeft left=0 right=1
sortRight left=2 right=2
mergeTogether left=0 mid=1 right=2

step 2

sortLeft left=0 right=0
sortRight left=1 right=1
mergeTogether left=0 mid=0 right=1

step 3

sortLeft left=2 right=2
sortRight left=3 right=2
mergeTogether left=2 mid=2 right=2




LC 912 排序

复习排序算法
https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/

LC 493

LC 654

=========================================================================================================

单调栈

5 6 4 7 5 2

以下模拟左边求第一个比当前小的数

-> 

5 6 
6 -> 4
5 -> 4
4 7
7 -> 5
4 5
5 -> 2
4 -> 2
2

以下模拟右边求第一个比当前小的数

2 5 7 
7 -> 4
5 -> 4
2 4 6
6 -> 5
2 4 5

1. 存游标会方便处理很多

LC 316 去除重复字母

有点坑，写的一塌糊涂，完全没有正确的思路

weiwei哥的题单
https://leetcode.cn/problems/remove-duplicate-letters/solutions/55044/zhan-by-liweiwei1419/

LC 42 接雨水
 
1.可以加一个哨兵值比如-1进去，也可以通过while循环里面判断栈为空则break的方式
2.实际栈中不是完全单调，需要考虑一样高度的柱子
3.还有面积叠加法(类似阳光照射)和动态规划(进一步可以优化成双指针)，复习的时候可以再做一下

LC 84 最大长方形面积 在histogram中

1.弹出的时候要特别小心，需要用当前弹出元素前面的index+1，因为我们能够弹出的元素都是之前递增的元素，所以一定是要把前面位置已经弹出的index记录的
2.左右2边分别用2个stack统计的做法，更容易理解，但和点1一样最终还是靠统计index位置，即使用peek

LC 221 最大正方形

实际不适合用单调栈，用dp比较合适

LC 255 付费的

LC 456 132模式

1.如果从前往后不太好想，就要试下从后往前去想找单调性
2.每次找到不满足当前预设的单调性的数字的时候，出栈，这个时候出栈的元素和栈顶的元素就可能构成的是另一个方向单调性的一对
  进一步，可以去记录这个出栈元素的最值，去和遍历方向的元素的值去进行比较，找答案

LC 769 最多能完成排序的块

不是这么显著的单调栈场景
1.单调可能是在不同的区间的最值基础上单调，e.g. 区间a和区间b的最大值/区间保持单调
2.基于点1的场景就要考虑在移出栈的元素后记录区间内的一个“最值”，而不是存放符合区间条件的所有值

LC 769 最多能完成排序的块2

和上一题基本一样的单调栈解法

==============================================================================================================================

单调队列

通用步骤
1.去尾，即腾出空间让对象入列
2.保持队列单调性，涉及到重新调整顺序的操作; 调整到合适位置后，将新元素入队列
3.返回最值，一般是头部

LC 239 滑动窗口最大值

模板题，没啥说的

LC 862 和至少为K的最短子数组

看清题目，是至少大于k
1.理解清楚左边指的是队列头，右边指的是队列尾，因为我们一般都是从左边开始进队列
2.一旦有说求子数组的和，乘积之类的，就要想是不是需要做前缀和/乘积的处理
3.有正有负值的场景，大概率是不能简单的去滑动窗口的，因为窗口里面的和不具备单调性


几个场景
1.如果s[i]<=s[j],i>j, 则s[j]一定会被s[i]“短路”，因为假设后面存在和大于k的子数组(s[x]-s[j]>=k)，则s[x]-s[i]>=k先行已经满足
  暗含的逻辑即遇到上面的场景要弹出s[j]，在队列中保持单调递增，这里从队尾开始进行判断弹出满足条件的元素
  如果不弹出，就可能会出现被前面一个高点的值给短路求不出解的情况，e.g. 3 6 10 8 9 17 k=8 最终是结尾的17-9=8满足要求
2.从队列头开始，如果当前s[i]-s[peekFirst()]>=k，则记录值，这里也有一个可以优化的点
  即假如s[i]-s[peekFirst()]>=k，则i再往后的元素都不会满足要求，因为后续的x>i，满足要求的子数组大小都会比当前的子数组大小要来的大


LC 1425 带限制的子序列和

1.子数组最大值，且满足相邻2个数坐标i和j之间的举例小于等于k，先看下什么方向，比如dp能不能搞

以元素i结尾的子序列中元素和的值最大值(子序列为空，所以必有元素) 即nums[i]一定是被pick了
dp[i] = max(nums[i], dp[i-j] + nums[i]) 枚举所有j的值 j = [1,k]

几种case
1.只选nums[i]，即i之前的序列为空
2.枚举宽度为k的窗口中所有的可能性, dp[i-k]到dp[i-1] while i-k>=0 小于0则取0

最终结果 max(dp[0], dp[1], ..., dp[nums.length - 1])

O(nk) 复杂度 基本会超时，看下怎么优化


[-10,-2,100,-5,-6,7] k=2


dp[0] = nums[0] = -10
dp[1] = max(nums[1], dp[0]+nums[1]) = -2
dp[2] = max(nums[2], dp[1]+nums[2], dp[0]+nums[2]) = max(100, 98, 90) = 100
dp[3] = max(nums[3], dp[2]+nums[3], dp[1]+nums[3]) = max(-5, 95, -7) = 95
dp[4] = max(nums[4], dp[3]+nums[4], dp[2]+nums[4]) = max(-3, 89, 94) = 94
dp[5] = max(nums[5], dp[4]+nums[5], dp[3]+nums[5]) = max(7, 102, 101) = 102


LC 1438 绝对差不超过限制的最长连续子数组

1.不超过限制提示我们会出现当前值i和前面一个片段的上下限都要判断，即比较区间最大值和最小值，最大最小值就要想下是不是保持2个栈去maintain窗口内的2个最值了
2.有窗口特征的，要想下怎么实现left和right的2个指针，并且在合适的时刻更新结果
3.窗口的缩小技巧性很强，缩小的条件是窗口中的最大和最小值相差的绝对值小于等于limit，每次循环累积递增left值，直到min或者max的队列最顶的元素被弹出
  while (Math.abs(nums[maxQueue.peekFirst()] - nums[minQueue.peekFirst()]) > limit) {
                // 进入这里一定是窗口需要调整了, left指向下一个可能valid的位置，这里非常绕，移动了left以后并不一定就到达了需要调整的窗口位置，即只有在下面left大于了max或者min的头节点位置才可能终止当前的循环，完成窗口的缩小
                left++;
                if (maxQueue.peekFirst() < left) {
                    maxQueue.pollFirst();
                }
                if (minQueue.peekFirst() < left) {
                    minQueue.pollFirst();
                }
                System.out.println("left in while -> " + left);
            }


LC 1696 跳跃游戏五

完全是1425的套娃题，解法完全一样，相对更简单一些

1.也可以写那种构建好窗口，然后求dp[i+1]，这种情况下就要从i=0到i=len-2结束

==============================================================================================================================

滑动窗口
 
通用模板
本质还是双指针，左指针left和右指针iterator i
1.进
  当前遍历的元素进入窗口，对应右指针i的移动
2.出
  判断是否符合条件缩小窗口，对应左指针left满足条件后向右的移动
  e.g. 
  while (condition satisfied) {
      update conditon
      left++;
  }
3.算
  一般是在2.的出完成，窗口有效后，更新，常用 i - left + 1 表达窗口的宽度


LC 3 无重复字符的最长子串

模板题，没有太多好说的

LC 159 最多有2个不同字符的最长子串

付费题

class Solution {
    public int lengthOfLongestSubstringWithAtMost2DistinctLetters(String s) {
        if (s == null || s.length == 0) {
            return 0;
        }

        // 滑动窗口
        int left = 0;
        int res = 0;
        Map<Character, Integer> charMemo = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            // current char
            char curChar = s.charAt(i);
            charMemo.put(curChar, charMemo.getOrDefault(curChar, 0) + 1);

            while (charMemo.size() > 2) {
                char leftChar = s.charAt(left);
                charMemo.put(leftChar, charMemo.get(leftChar) - 1);
                if (charMemo.get(leftChar) == 0) {
                    charMemo.remove(leftChar);
                }
                left++;
            }
            res = Math.max(res, i - left + 1);
        }

        return res;
    }
}

LC 340 最多k个不同字符的最长子串

付费题 完全就是LC159的套娃

LC 76 最小覆盖子串

1.题目看清楚，最大最小，返回类型是子串
2.Integer之类的对象类型的一定要注意是用equals去比较，不是==
3.以下做法还能优化，只需要一个map就能记录 
  通过map记录每个letter在字符串t中出现的次数
  通过一个validCount记录多少个字符已经符合要求，一旦符合要求即可以缩小窗口，缩小窗口后判断left指向的字符从tmpMap里面更新，如果减到0则validCount--

LC 395 至少有K个重复字符的最长子串

1.创造单调性场景，多个变化影响条件的话就要想办法fix其中一个进行枚举

LC 209 长度最小的子数组

1.进阶的nlogn做法也要想下

LC 424 替换后的最长重复字符

1.不要被LC209给干扰，上来就想着fix一个字符

LC 219 存在重复元素2

1.没想到可以用滑动窗口去解

LC 567 字符串的排列

1.滑动窗口应用，用固定单词窗口移动的方式进行计算会更好
  for (i = wordLen; i < s.length(); i++) {
      count[s.charAt(i) - 'a']++;
      count[s.charAt(i - wordLen) - 'a']--;
      if(checkValid) return true;
  }
  
LC 992 k个不同整数的子数组

1.从左往右开始循环i 也可以理解成每次固定i然后计算左边left到i之间的区间是否有大于k个不同元素

LC 1248

1.和992基本完全一致

==============================================================================================================================

排序十讲

常考的

quickSort (quickSelect)

mergeSort


bucketSort
countingSort
heapSort


考的少的

bubbleSort


selectionSort

https://www.geeksforgeeks.org/selection-sort/

void sort(int arr[])
    {
        int n = arr.length;
 
        // One by one move boundary of unsorted subarray
        for (int i = 0; i < n-1; i++)
        {
            // Find the minimum element in unsorted array
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
 
            // Swap the found minimum element with the first
            // element
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }

insertion sort

把每个元素放到他们该在的位置


shell sort

1.insertion sort是插入排序的基础
2.有不同的实现方式



LC 215 kth largest element in an array


partition的套路写法一

流程要点
1.random位置
2.将位置换到右边尾部，然后iterate i每个元素和end比较，只有小于才移动慢指针
3.最后要记得把end位置和满指针位置交互，满指针最后对应的位置就是1.random出来的元素应该在的位置

几个细节点
1.partition里面如果把random出来的位置调整到left就是头上，要注意返回的wall位置需要-1
  所以默认写法基本都是放到right，这样返回的wall位置不用记-1
2.random出来的元素不管放到头上还是尾上都只需要for循环剩下来的位置就可以了
3.有写一个helper递归调用的写法，也有while true的写法，建议都掌握

private int partition(int[] nums, int start, int end) {
        // 随机取pivot
        int pivot = new Random().nextInt(end - start + 1) + start;
        swap(nums, start, pivot);
    
        int slowIndex = start + 1;
        for (int i=start + 1; i<=end; i++) {
            if (nums[i] < nums[start]) {
                swap(nums, slowIndex, i);
                slowIndex++;
            }
        }

        swap(nums, start, slowIndex - 1);

        return slowIndex - 1;
    }

public int findKthLargest(int[] nums, int k) {
        int targetIndex = nums.length - k;
        int left = 0, right = nums.length - 1;
        while (true) {
            int index = partition(nums, left, right);
            if (index < targetIndex) {
                left = index + 1;
            } else if (index > targetIndex) {
                right = index - 1;
            } else {
                return nums[targetIndex]; 
            }
        }
    }


partition的套路写法二

流程要点
1.while循环里面left++ right-- 实际上本质和for循环没有区别
2.类似的也是需要将random出来的位置调整到start或者end的位置
3.口诀
  如果是pivot调整到end位置，则逻辑遍历从start到end-1，最后返回start
  如果是pivot调整到start位置，则逻辑遍历从start+1到end，最后返回end
  即都是返回的那个离pivot较远的位置，如果pivot在end，则返回start；pivot在start，则返回end

private int partition(int[] nums, int left, int right) {
        // while循环2边搜索的写法
        int pivot = new Random().nextInt(right - left + 1) + left;
        swap(nums, pivot, right);
        int start = left, end = right - 1;
        
        while (start <= end) {
            if (nums[start] <= nums[right]) {
                start++;
            } else if (nums[end] >= nums[right]) {
                end--;
            } else {
                swap(nums, start, end);
                start++;
                end--;
            }
        }
        
        swap(nums, start, right);
        return start;
    }

排序十讲

mergeSort

1.注意devide返回值获取的写法，可能会更直接容易理解一些

LC 148 排序链表

1.其实的fast指针要往前走一步，否则会无限循环；还有一个写法是while循环里面fast和fast.fast都判断是不是null
   while (fast.next != null && fast.next.next != null) {
   }

Inversion Pairs

1.特别小心在做merge的时候，判断条件里面是用tmp还是当前的nums，如果先copy到了tmp，就要用tmp

LC 75 Sort Colors

1.2堵墙，即2个指针的解法，不太好想到；有一个高阶技巧是iterate i里面改变i的值
  每次判断0是否在lowerWall的后面，2是否在higherWall的前面

bucket sort 桶排序 有用，会考到

LC 451 根据字符出现频率排序

1.桶排序，记住了就好写，关注怎么实现一个桶的数据结构即可
2.复习的时候可以尝试List<int[]>或者int[][]的写法

LC 164 最大间距

radix sort 基数排序，暂时拉黑没做，有点恶心

LC 969 pancake sort 煎饼排序

写了，这个只要是记住就好写


==============================================================================================================================

前缀和

LC 560 和为k的子数组

1. 前缀和+2sum，更优的写法可以一边算前缀和一边去做2sum判断，复习的时候可以写一下这个方法


LC 974 

LC 523

1.上面2个题目基本就是套娃题，要注意下求余数为0和负数的边界情况

LC 525 连续数组

1.0和1差值问题，比较难想

LC 370

===========================================================================

双指针

LC 408 有效单词缩写

1.写起来有点恶心，边界条件实际很多，复习的时候再好好做一遍

LC 15 3sum

1.写起来一定要搞清楚怎么去重，各元素之间的关系

LC 253 会议室2

1.扫描线，后面再单独学习下

LC 42 接雨水

1.通过dp双指针做更简单能想到

LC 141 环状链表

LC 142 环状链表2

1.可以优化掉一个变量

===========================================================================

扫描线

LC 56 合并区间

1.非常容易忘点 1和4 2和3 这种场景；另外就是处理到最后一个元素的时候怎么办

LC 57 合并区间2

1.搞清楚当前pair和需要进行处理的区间的关系，代码就好写了

LC 1272 删除区间

1.独立做出来了，实际还能再优化

LC 435 无重叠区间

1. [[1,4],[5,11],[2,3],[3,4]] 直接测出了问题
   可以更优化，复习的时候再做一遍，第一遍的做法比较笨，没有反过来用剩余的区间数量去做贪心

LC 1288 删除被覆盖区间

1.和上面的类似，也是可以优化的，思路其实都是通过排序然后for循环里面一边固定，比如start都是递增的
  然后end递减，一旦遇到比保存的end小的则说明一定是被覆盖了就需要删除，则跳过，if (cur<=a[1])

LC 352 将数据流变为多个不相交区间

1.使用TreeSet解，要求对lower和higher熟悉
2.如果不用TreeSet怎么解？

LC 1229 安排会议日程

1.求共同区间可以写的更简单，min和mx取完，相减，没有overlap的场景会因为求出来的值为负数不满足duration要求直接过滤

LC 986 区间列表的交集

1.对1229的套娃题，写的比较正常

LC 759 员工空闲时间

1.困难题，实际只要能识别外面一层皮就很好解

LC 218 天际线问题

1.困难题，找到规律比较难，扫描线结合pq的解法，应该有更优化的解

===========================================================================

经典题系列

第一讲 计算器

LC 224 基本计算器

1. 从最基本形态一步步演变
   - 没有括号，没有乘除，只有+ - 和数字
   - 有+ - * /
   - 加上括号
2. 边界条件还是很恶心的
   - 结束需要触发入栈或者结束的条件
     遇到 ) 是已经结束了，需要入栈
     遇到最后一个字符需要出栈进行计算

LC 227 基本计算器2

LC 772 基本计算器3

1. 以上2道题目类似，复习的时候可以看下能不能尝试下循环的写法
2. stack也是可以优化成o1的

===========================================================================

经典题系列

第三讲 topK

LC 347 前K个高频元素

1.用minHeap可以卡k个解法
2.pq的lambda可以用外面申明的map，这样里面可以只存key就可以了
3.可以无脑先offer，超过k个再poll，会比较简化
4.可以使用Java.util.Arrays.copyOfRange() in Java

比nlogk还能再快点，quickSelect
1.复习了二分查找的写法，用的递归做法，可以再看下while循环的写法

还可以用bucketSort的做法
1.会稳定拿到o(n)的时间复杂度，空间换时间，复习的时候可以做下

几个优化场景
1.k非常大怎么办？
2.元素区分度不够，可能退化为n*n，怎么优化？3 way pivot

LC 703 kth largest element in a stream

1.用pq的写法是最简单的，不过要考虑到follow up
  - 如果不是一个stream，一次全部给你所有数据，且多次查询，每次k值不一样？查询次数还非常多，怎么办？

LC 1032 字符流 倒序topK

1.实际不算是topk问题，就是一个字典树

=========================================================================================================

经典题系列

第四讲 股票问题

通用模型
T[i][k][0 .. 1]
k=买卖次数
i=当前天数
0或者1表示状态，是否持有股票

LC 121 最多一次买入卖出

LC 122 无限次买入卖出

1.复习的时候可以看下贪心的做法怎么解

LC 714 含手续费

1.复习的时候可以看下状态压缩怎么做

LC 309 带冷冻期的

LC 123 k介入计算的场景

LC 188 k介入计算的场景

股票问题总结，讲的最好的一篇
https://leetcode.cn/circle/article/qiAgHn/

=========================================================================================================

经典题系列

第五讲 jump game

LC 55 跳跃游戏1

1.复习的时候开始没思路，且边界条件各种漏，比如只有size=1等
2.可以想下用dfs怎么写，实际这个问题就是一个dfs

LC 45 跳跃游戏2

1.想要证明会非常麻烦，用贪心的做法也不好理解
2.用dp相对会直观一些

LC 1306 跳跃游戏3

1.dfs或者bfs

LC 1345 跳跃游戏4

1.bfs用queue做，已经忘了怎么记层数了，另外就是可能出现超时的场景，要remove
2.可以看下宫水三叶的文章
https://leetcode.cn/problems/jump-game-iv/solutions/1223307/gong-shui-san-xie-noxiang-xin-ke-xue-xi-q9tb1/
https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490011&idx=1&sn=4c8cbd5ad858f571291d47fcef75e75b&chksm=fd9cb2c4caeb3bd2ac442b2d4d1417e8eb6d65b1feca8399179951ebfa132e8a97a3935e7498&token=252055586&lang=zh_CN#rd
3.双向bfs的优化技巧
  比较高阶，可以了解写一写

LC 1340 跳跃游戏5

1.dfs+memo，有规律可循的，如果是可能双向跳的，大概率是dfs搜索等

LC 1696 跳跃游戏6

1.这题能走的方向是单向，且出现了求最xx字样，大概率是走一遍的dp类，且加上单调栈或者其他的优化
2.本题可以复习pq和单调队列2种写法

LC 1871 跳跃游戏7

1.通过栈模拟

LC 403 青蛙过河

1.dfs最暴力，不行就要想优化成dp
2.最巧妙的还是类似动态规划的做法
3.可以参考看下三叶的做法
https://leetcode.cn/problems/frog-jump/solutions/750427/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/

最终核心知识点都是
dfs -> dfs+memo (dp) -> bfs 
如果是单向的，大概率sliding window，单调队列(pq)，最后才考虑greedy

=========================================================================================================

经典题系列

第六讲 括号类问题

知识点

1.类似rolling state的思路，左右平衡
2.stack用来处理复杂的情况，不同类型的括号/括号index/前一层的数字号
3.backtracking类似subset用来生成括号

LC 1614 括号的最大嵌套深度

1.rolling state解法

LC 921 使括号有效的最少添加

1.左右欠债的写法会更逻辑通顺

LC 1249 移除无效的括号

1. 2pass思路不太好想，复习的时候可以做下
2.直接写法就是通过辅助栈 删除每一个不符合的位置

LC 856 括号的分数

1.我的解法是纯模拟，
2.题解的方法更抽象，和计算器非常类似，很不好想，把前一步的结果存到栈里再计算

LC 32 最长有效括号

1.通过stack模拟，也是类似的用到了-1作为哨兵的技巧
2.栈里面要注意可能是存index
3.stack和2 pass 2种写法都要理解掌握

以下为使用到了dfs/backtracking的题目

LC 22 括号生成

1.dfs backtracking 想起来不好弄

LC 241 为运算表达式设计优先级

1.识别不出来场景就没法做，左右分别切出值之后，再组合结果，注意res定义的位置

LC 301 删除无效的括号

1.最后一题，有点绕，几个边界条件一定注意的
 - 左括号需要删除的和右括号需要删除的可以记下
 - 还要统计记录open的括号数不能大于0,不要出现 )( 这种场景
 - 去重

===========================================================================

经典题系列

第七讲 2sum系列

LC 1 2sum

1.没啥说的，最多复习想下双指针怎么做

LC 167 两数之和2 输入有序数组

1.双指针

LC 170 两数之和3 数据结构设计

1.要考虑add还是find多，不同的数据结构

LC 653 两数之和4 输入二叉搜索树

1.转化为有序列表+双指针
2.传set+dfs也能解
3.能否优化为o(h)的空间复杂度？
  需要掌握iterator的写法，通过一个stack去记录，可以把空间复杂度压缩到h

LC 173 迭代器

1.可以用在653题中，必须要掌握
2.解法和二叉树的中序遍历一样，复习下中序遍历的迭代写法
  while root!=null || !stack.isEmpty()
  - 当前root的左子树一直循环入栈 (利用栈记录了所有的左子树的轨迹)
  - 弹出当前栈顶元素，作为当前节点，进行处理
  - 将弹出的当前节点的右子树换为当前节点

LC 15 3sum

1.老题了，复习的时候还是要特别小心去重的场景，以及在哪里写去重逻辑

LC 18 四数之和

1.还是按照3sum的套路，但要注意几个边界条件
  - 多个数字和加起来超过int大小
  - 在前面2个循环开始的地方都要进行去重，且第2个循环开始的地方也是要判断j多1的场景进行去重

LC 454 四数之和 2

1.从4个array里面取，把题目转换为2个2sum

LintCode 89 kSum
https://www.lintcode.com/problem/89/

给定 n 个不同的正整数，整数 k(k \leq n)(k≤n)以及一个目标数字 target。　
在这 n 个数里面找出 k 个数，使得这 k 个数的和等于目标数字，求问有多少种方案？

A = [1,2,3,4]
k = 2
target = 5
输出 2

此类问题一般2个方向
1.求多少种组合，这种要比较敏感能想到去走递推求解法 -> dp
2.求每个组合的值 -> dfs backtracking

LintCode 90 kSum 2
https://www.lintcode.com/problem/90/description

https://www.lintcode.com/problem/90/record
1.dfs解法
2.转换为2sum的解法，也要掌握，用递归的方式调用自己

以上2个什么场景使用，时间复杂度多少?

===========================================================================

经典题系列

第八讲 回文系列

1. 常见解法 dp 中心扩散 暴力解 greedy dfs
2. kmp rolling hash 就不做要求了

LC 680 验证回文串2

1. n复杂度，考察对删除最多1个字符+回文判断的理解

LC 9 回文数

1. 数字如何通过 /10 %10 之类的办法进行翻转
   这是一个模板，需要熟练掌握
2. 翻转完只需要比较头一半，不需要尾部再比较，因为翻转后的一半就是翻转前的另一半
3. 用2.的解法需要注意

LC 234 回文链表

知识点
1.reverse链表
  - 翻转链表很容易忘记，要记住要点: a.双指针 b.返回的是pre
  - 递归的写法也要锻炼下
  - 测试下不声明本地的cur变量，会不会有问题，加强对内存的理解
2.快慢指针找中间节点
  有2种写法，一种是判断fast和fast.next都不为null，这个时候加个dummy节点才行；另一种写法是fast.next和fast.next.next不为null，这个时候就不用dummy节点
  奇数和偶数场景都要自己推演下
3.还可以用数学方法做，即类似LC 9 回文数字的做法

子主题 DP或者中心扩散法

LC 5 最长回文子串

1.dp写法相对慢一些，写的时候注意不一定必须要maxLength参数
2.写的时候还是遵循定义会好想一些
  - i和j标识start和end，start一般在前，end一般在后
  - j>=i

LC 647 回文子串

1.是LC5的套娃题，也是2种方法都可以复习下

子主题 DP and SubSequence

LC 516 

1.中心扩展法就不能用了，因为不连续了
2.通过dp去解

子主题 回文和backtracking的结合

LC 131 分割回文串1

LC 132 分割回文串2

1.递推公式写的不对

几个板子要记熟练记住
1. dp判断子串是否为回文串，并可以更新最大
2. 中心扩散解法

========================

经典题系列 

第九讲 我的日程

LC 729 日程安排1

1.使用treemap判断最近的元素寻找overlap
2.更标准的是线段树做法
线段树做法整理
https://leetcode.cn/problems/my-calendar-i/solutions/1646079/by-lfool-xvpv/


LC 731 日程安排2

1.用treeMap维持有序，差分数组解法，和数飞机一样

LC 732 日程安排3

1.和数飞机一样的做法，但会很慢
2.正常的做法还是线段树，需要学习
https://leetcode.cn/problems/my-calendar-iii/solutions/1537773/xian-duan-shu-by-xiaohu9527-rfzj/

=========================================================================================================

动态规划系列

第一讲 博弈类

LC 292 Nim游戏

1.玩石头，dp+memo

LC 486 预测赢家

1.dp+memo 净胜分转移

LC 1025 除数博弈

1.还是dp+memo 最终可以转为数学场景

LC 877 石头游戏1

1.和LC 486几乎套娃，但最优解是数学做法

LC 1140 石头游戏2

1.集合后缀和可以解，但边界条件很多

LC 1406 石头游戏3

和石头游戏1几乎套娃

LC 1510 石头游戏4

===========================================================================

动态规划系列

第二讲 单序列

LC 70 和 LC 91 

1.都是简单的斐波拉切模式

LC 139 单词拆分1

1.我是按照dp和dfs去了解2种不同写法的，实际上是一回事情，只是同一种写法的迭代和递归2种方式
2.写dp的时候要注意边界条件，比如dp是取N还是N+1，i和j的边界

LC 140 单词拆分2

1.我是和和LC 139的做法类似
2.复习的时候可以尝试下预加算dp再进行计算的做法

LC 53 最大子数组和

1.类似dp，还是比较简单

LC 152 最大子数组乘积

1.记录正数和负数各自对应的绝对值最大值
2.要小心参数的更新，状态压缩不一定就很好

LC 198 打架劫舍

1.经典题，dp解法

LC 121 股票1

1.经典题，复习下模型需要的3个维度 i=第几天 j=买卖次数 k=状态(持有/未持有)

LC 300 最长递增子序列

1.经典题，复习n^n的解法
2.nlogn的解法需要掌握，知识点是dp+二分查找，有点像单调栈但又不是非常不好想

LC 1713 

1.和LCS很像，但不能用这个去做
2.想法非常巧妙，还是找递增关系，只不过这次找的内容转换为index，变成了LC 300
  也是属于LIS的变种

当其中一个数组元素各不相同时，最长公共子序列问题（LCS）可以转换为最长上升子序列问题（LIS）进行求解。
同时最长上升子序列问题（LIS）存在使用「维护单调序列 + 二分」的贪心解法，复杂度为 O(nlog⁡n)

可以看下三叶的总结
https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/solutions/896862/gong-shui-san-xie-noxiang-xin-ke-xue-xi-oj7yu/

LC 1807 

当天的每日一题 20230112
1.模拟，但可以更优化，遇到左括号需要干什么，遇到有括号需要干什么；


===========================================================================

动态规划系列

第三讲 双序列

什么是双序列？i和j表达前i个和前j个字符能表述的状态

状态：第一个的前i个和第2个的前j个所表达的状态
选择：第1个少选一个，第2个少选一个，或者2个都不选
起点: 一般dp[0][j]和dp[i][0]表示的是其中一个是空串的场景
终点: 2个string都到达的终点，即m-1和n-1的位置

LC 1143 LCS 最长公共子序列

1.模板题，可以作为多道其他题目的helper方法，必须熟练默写
2.状态压缩的解法可以参考下面这篇
https://leetcode.cn/problems/longest-common-subsequence/solutions/697027/er-wei-shu-zu-dphe-yi-wei-shu-zu-dpde-sh-w96r/

LC 97 交错字符串

1.还是双循环dp，写起来有点吐血，没想起楚

LC 72 编辑距离

1.dp写法，要想明白递推公式就简单，这次变化是出现了dp[i+1][j] = dp[i+1][j] dp[i][j+1] 这个脑子里面matrix图要想清楚
  自己最好写一个matrix练习下推导
2.dfs写法也可以做，可以后续练习下

LC 115 不同的子序列

1.dfs+memo比较好写一点
2.iterative写法比较难想，要从i往i-1去想

LC 10 正则匹配

1.dfs+memo好写，但边界条件很多，特别是memo的size
2.dp迭代写法，要小心空串和.*能够匹配的场景，这个边界条件很容易漏，具体到代码就是i从0开始，j从1开始

LC 44 通配符匹配

1.dfs+memo写出来之后初始化非常难理解，不好想
2.dp iterative写法，很容易忘记空串和*的匹配场景的初始化，导致最后case不对

LC 1312 让字符串成为回文串的最少插入次数

1.思路牛逼，完全想不到，就是一个lcs模板的应用
2.为啥lcs模板我的这么慢

LC 516 Longest Palindromic SubSequence

1.还是lcs模板的应用，自己和自己的reverse比较，和1312完全一样
2.更快的做法是常规dp求解
3.后续可以尝试下dfs求解

LC 1216 valid 回文 3
